# Story 1.2: Database Schema & Captures Table

## Status

Done

## Story

**As a** developer,
**I want** a Supabase database schema with a captures table and Row Level Security policies,
**so that** I can store user content (texts, photos, videos, URLs) with proper data isolation and timestamps.

## Acceptance Criteria

1. **Captures Table Created**: PostgreSQL table with columns for id, user_id, content_type, text_content, media_url, timestamp, metadata
2. **User Profile Table**: Simple users table to store phone numbers and basic profile info
3. **RLS Policies Enabled**: Row Level Security ensures users can only access their own captures
4. **Migration Files**: Supabase migration files created and applied successfully
5. **Type Definitions**: TypeScript types generated from database schema
6. **Local Development**: Supabase local development environment running via Docker

## Tasks / Subtasks

- [x] **Task 1: Setup Supabase Local Development** (AC: 6)
  - [x] Install Supabase CLI
  - [x] Initialize Supabase project locally (`supabase init`)
  - [x] Start local Supabase services via Docker
  - [x] Verify local Supabase dashboard accessible at localhost:54323

- [x] **Task 2: Create Users Table Migration** (AC: 2)
  - [x] Create migration file: `supabase/migrations/001_create_users_table.sql`
  - [x] Add users table with: id (uuid primary key), phone_number (text unique), created_at (timestamp), birth_date (date)
  - [x] Add index on phone_number for fast lookups
  - [x] Apply migration locally: `supabase db push`

- [x] **Task 3: Create Captures Table Migration** (AC: 1)
  - [x] Create migration file: `supabase/migrations/002_create_captures_table.sql`
  - [x] Add captures table with columns:
    - id (uuid primary key, default gen_random_uuid())
    - user_id (uuid foreign key to users.id)
    - content_type (text - 'text', 'photo', 'video', 'url')
    - text_content (text nullable - for text messages)
    - media_url (text nullable - for photos/videos)
    - location_name (text nullable - subjective location label)
    - latitude (decimal nullable - geographic coordinate)
    - longitude (decimal nullable - geographic coordinate)
    - metadata (jsonb nullable - for URLs, timestamps, etc.)
    - created_at (timestamp with time zone, default now())
  - [x] Add index on user_id for fast user queries
  - [x] Add index on created_at for chronological sorting
  - [x] Apply migration locally

- [x] **Task 4: Implement Row Level Security** (AC: 3)
  - [x] Create migration file: `supabase/migrations/003_enable_rls.sql`
  - [x] Enable RLS on users table
  - [x] Enable RLS on captures table
  - [x] Add RLS policy: users can read their own user record
  - [x] Add RLS policy: users can insert/read/update/delete only their own captures
  - [x] Apply migration locally

- [x] **Task 5: Generate TypeScript Types** (AC: 5)
  - [x] Run `supabase gen types typescript` to generate types from schema
  - [x] Save types to `lib/supabase/database.types.ts`
  - [x] Update Supabase client utilities to use generated types
  - [x] Verify TypeScript compilation passes with new types

- [x] **Task 6: Test Schema Locally**
  - [x] Insert test user record via Supabase local dashboard
  - [x] Insert test capture records for user
  - [x] Verify RLS policies work (can't access other users' captures)
  - [x] Verify indexes exist and queries are efficient

## Dev Notes

### Epic Context (from PRD v5.0)

**Epic 1 Goal**: Set up Next.js app, Supabase database, phone authentication, and Twilio SMS integration. Users can text a number and content appears on web dashboard.

This story establishes the database foundation for capturing user content. Story 1.1 set up the Next.js app and Supabase connection - now we create the actual database schema.

### Previous Story Insights (from Story 1.1)

**Key Learnings**:
- Supabase cloud project already created and connected
- Environment variables configured in `.env.local` (NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY)
- Supabase client utilities created at `lib/supabase/client.ts` and `lib/supabase/server.ts`
- TypeScript strict mode enabled
- Monorepo structure: `app/` for Next.js, `supabase/` for migrations

**Note**: We now need to add local Supabase development for safe migration testing before pushing to production.

### Repository Structure (from PRD)

```
reality/
├── app/              # Next.js application (frontend + API routes)
├── supabase/         # Database migrations, Edge Functions, RLS policies
│   └── migrations/   # SQL migration files (created in this story)
├── lib/
│   └── supabase/     # Client utilities (already exist from Story 1.1)
├── docs/             # PRD, architecture, stories
└── .bmad-core/       # BMAD agent system
```

**New in This Story**: `supabase/migrations/` folder with SQL files.

### Data Models (from PRD Requirements)

**Functional Requirements relevant to schema**:

- **FR1**: Users send text messages → `captures` table needs `text_content` column
- **FR2**: Users send photos → `captures` table needs `media_url` column for Supabase Storage URLs
- **FR3**: Users send videos → `captures` table needs `media_url` column
- **FR4**: System preserves URLs → `captures` table needs `text_content` for URL strings + `metadata` jsonb for parsed URL data (TikTok, Reels, YouTube)
- **FR5**: Users identified by phone number → `users` table needs `phone_number` column (unique)
- **FR10**: System captures timestamps → `captures` table has `created_at` timestamp

**Content Types**:
- `text` - Plain text message
- `photo` - Photo with media_url pointing to Supabase Storage
- `video` - Video with media_url pointing to Supabase Storage
- `url` - URL with text_content containing the URL string

### Database Schema Design

**Users Table**:
```sql
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  phone_number TEXT UNIQUE NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

CREATE INDEX idx_users_phone ON users(phone_number);
```

**Captures Table**:
```sql
CREATE TABLE captures (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  content_type TEXT NOT NULL CHECK (content_type IN ('text', 'photo', 'video', 'url')),
  text_content TEXT,
  media_url TEXT,
  location_name TEXT,
  latitude DECIMAL(10, 8),
  longitude DECIMAL(11, 8),
  metadata JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

CREATE INDEX idx_captures_user_id ON captures(user_id);
CREATE INDEX idx_captures_created_at ON captures(created_at DESC);
```

**Note**:
- `location_name` stores subjective location label (e.g., "Home", "Coffee shop", "Mom's house")
- `latitude` and `longitude` store objective geographic coordinates for Google Maps integration
  - Latitude: DECIMAL(10, 8) allows range -90.00000000 to 90.00000000 (~1.1mm precision)
  - Longitude: DECIMAL(11, 8) allows range -180.00000000 to 180.00000000 (~1.1mm precision)
  - Both nullable - user may not always provide location
- `created_at` uses `TIMESTAMP WITH TIME ZONE` which captures full date (year, month, day), time (hour, minute, second, milliseconds), and timezone offset
- `metadata` is jsonb for flexible storage of:
  - URL metadata (TikTok video IDs, YouTube links, etc.)
  - Future features (labels, connections will be separate tables in later stories)

### Row Level Security (RLS) Policies

**Users Table RLS**:
```sql
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

-- Users can read their own profile
CREATE POLICY "Users can read own profile"
  ON users FOR SELECT
  USING (auth.uid() = id);
```

**Captures Table RLS**:
```sql
ALTER TABLE captures ENABLE ROW LEVEL SECURITY;

-- Users can insert their own captures
CREATE POLICY "Users can insert own captures"
  ON captures FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Users can read their own captures
CREATE POLICY "Users can read own captures"
  ON captures FOR SELECT
  USING (auth.uid() = user_id);

-- Users can update their own captures
CREATE POLICY "Users can update own captures"
  ON captures FOR UPDATE
  USING (auth.uid() = user_id);

-- Users can delete their own captures
CREATE POLICY "Users can delete own captures"
  ON captures FOR DELETE
  USING (auth.uid() = user_id);
```

**Security Note**: `auth.uid()` returns the authenticated user's ID from Supabase Auth session. This ensures complete data isolation between users.

### Supabase Local Development Workflow

1. **Install CLI**: `npm install -g supabase` (or use npx)
2. **Initialize Project**: `supabase init` creates `supabase/` folder with `config.toml`
3. **Start Services**: `supabase start` launches Docker containers (Postgres, Auth, Storage, Realtime)
4. **Access Dashboard**: http://localhost:54323 for local Supabase Studio
5. **Create Migrations**: Add `.sql` files to `supabase/migrations/` folder
6. **Apply Migrations**: `supabase db push` applies pending migrations
7. **Generate Types**: `supabase gen types typescript --local > lib/supabase/database.types.ts`

**Why Local Development?**:
- Test schema changes safely before production
- Faster iteration (no cloud sync delays)
- Works offline
- Easy to reset (`supabase db reset`)

### TypeScript Type Generation

After migrations are applied, generate types:

```bash
supabase gen types typescript --local > lib/supabase/database.types.ts
```

This creates TypeScript interfaces matching the database schema. Update Supabase client to use these types:

```typescript
// lib/supabase/client.ts
import { Database } from './database.types'
import { createBrowserClient } from '@supabase/ssr'

export const createClient = () =>
  createBrowserClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
```

### Tech Stack (from PRD - relevant to this story)

- **Database**: Supabase PostgreSQL with Row Level Security
- **Local Dev**: Docker (for Supabase local services)
- **Migrations**: SQL files in `supabase/migrations/`
- **Type Safety**: TypeScript types auto-generated from schema

### File Locations

- Migration files: `supabase/migrations/00X_migration_name.sql`
- Generated types: `lib/supabase/database.types.ts`
- Supabase config: `supabase/config.toml` (auto-generated by `supabase init`)

### Testing

**Testing Strategy for This Story**:

Since this is database schema setup, testing focuses on **manual verification** rather than automated tests:

1. **Migration Success**: Verify migrations apply without errors
2. **Schema Verification**: Check tables exist with correct columns via Supabase Studio
3. **RLS Testing**: Manually test that RLS policies prevent unauthorized access
4. **Type Generation**: Verify TypeScript compilation succeeds with generated types

**No Vitest unit tests required** - schema testing is manual for this foundational story.

**Testing Procedure**:
- Insert test user via Supabase local dashboard
- Insert test captures for that user
- Attempt to query captures as different user (should fail due to RLS)
- Verify indexes are created: `EXPLAIN ANALYZE SELECT * FROM captures WHERE user_id = 'xxx'`

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-27 | 1.0 | Created Story 1.2 from PRD v5.0 | SM Bob |

## Dev Agent Record

*This section will be populated by the Dev agent during implementation.*

### Agent Model Used

Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References

No debug log entries required for this story.

### Completion Notes

- Successfully set up Supabase local development environment with Docker
- Created three migration files: users table, captures table, and RLS policies
- All migrations applied successfully to local database
- Generated TypeScript types from database schema
- Updated Supabase client utilities (client.ts and server.ts) to use generated Database types
- TypeScript compilation passes with no errors
- Local Supabase Studio accessible at http://127.0.0.1:54323 for manual testing
- Database schema includes proper indexes for performance (user_id, phone_number, created_at)
- RLS policies implemented for complete data isolation between users

### File List

**New Files:**
- `supabase/config.toml` - Supabase project configuration (auto-generated)
- `supabase/migrations/20251027000001_create_users_table.sql` - Users table schema
- `supabase/migrations/20251027000002_create_captures_table.sql` - Captures table schema
- `supabase/migrations/20251027000003_enable_rls.sql` - Row Level Security policies
- `supabase/migrations/20251027000004_add_users_update_policy.sql` - UPDATE policy for users (added during QA)
- `supabase/migrations/20251027000005_add_user_name.sql` - Name column for onboarding (added during QA)
- `lib/supabase/database.types.ts` - TypeScript types generated from database schema

**Modified Files:**
- `lib/supabase/client.ts` - Added Database type to createBrowserClient
- `lib/supabase/server.ts` - Added Database type to createServerClient

## QA Results

### Review Date: 2025-10-27

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall: Excellent foundational schema implementation**

The database schema is well-designed and properly implements all acceptance criteria. The migration files are clean, well-documented with SQL COMMENT statements, and follow PostgreSQL best practices. The implementation demonstrates strong understanding of:

- Row Level Security for multi-tenant data isolation
- Performance optimization through strategic indexing
- Type safety via TypeScript type generation
- Referential integrity with CASCADE constraints

**Verification Completed:**
- ✓ Both tables (users, captures) exist in local Supabase database
- ✓ All columns match specification exactly (verified via `\d captures`)
- ✓ RLS enabled on both tables (rowsecurity = true)
- ✓ All 5 RLS policies created and active
- ✓ Indexes created: idx_users_phone, idx_captures_user_id, idx_captures_created_at
- ✓ Content type constraint enforces allowed values: text, photo, video, url
- ✓ Foreign key constraint with ON DELETE CASCADE
- ✓ TypeScript types generated and integrated into client utilities
- ✓ Build passes with type checking (next build ✓)
- ✓ Supabase Docker containers healthy and running

### Refactoring Performed

No refactoring needed. Implementation is clean and follows best practices.

### Compliance Check

- **Coding Standards**: ✓ Well-documented SQL with COMMENT statements
- **Project Structure**: ✓ Migrations in supabase/migrations/, types in lib/supabase/
- **Testing Strategy**: ✓ Manual verification approach appropriate for schema story
- **All ACs Met**: ✓ All 6 acceptance criteria fully implemented

### Schema Design Review

**Strengths:**
1. **Proper Data Types**: DECIMAL(10,8) and DECIMAL(11,8) for lat/long provides 1.1mm precision
2. **Timezone Awareness**: TIMESTAMP WITH TIME ZONE captures full temporal context
3. **Flexible Metadata**: JSONB allows evolution of URL metadata without schema changes
4. **Performance Ready**: Strategic indexes on high-query columns (user_id, created_at, phone_number)
5. **Data Integrity**: Foreign key CASCADE ensures orphan prevention
6. **Documentation**: Inline SQL comments explain design decisions
7. **Media Storage Pattern**: Correctly uses URL references (media_url TEXT) instead of storing binary data in database - follows industry best practice of storing media files in object storage (Supabase Storage) and URLs in database

**Security Analysis:**

**Captures Table RLS** - ✓ PASS
- INSERT policy: Users can only insert captures with their own user_id
- SELECT policy: Users can only read their own captures
- UPDATE policy: Users can only update their own captures
- DELETE policy: Users can only delete their own captures
- **Verdict**: Complete CRUD isolation. Secure.

**Users Table RLS** - ✓ PASS (with deferred decision)
- SELECT policy: Users can read their own profile ✓
- UPDATE policy: Users can update their own profile ✓ (added in migration 004)
- INSERT policy: **Intentionally deferred** - decision depends on auth flow chosen in Story 1.3+

**Note**: INSERT policy decision deferred to implementation stories:
- If client-side signup: Add RLS INSERT policy (`auth.uid() = id`)
- If backend-managed signup: Use service role (no policy needed)
- Current schema supports both approaches

### Non-Functional Requirements Validation

**Performance** - ✓ PASS
- Query optimization ready with proper indexes
- DECIMAL precision appropriate (not over-engineered)
- JSONB allows flexible querying without schema changes

**Reliability** - ✓ PASS
- CASCADE delete prevents orphaned captures
- NOT NULL constraints on critical fields (user_id, content_type, phone_number)
- CHECK constraint prevents invalid content_type values
- Timestamp defaults ensure data always timestamped

**Maintainability** - ✓ PASS
- Excellent SQL documentation via COMMENT statements
- Clear migration file naming with timestamps
- TypeScript types auto-generated (reduces manual sync)
- Self-documenting column names

**Security** - ✓ PASS
- Captures table: Fully secured with all CRUD policies ✓
- Users table: SELECT + UPDATE policies in place ✓
- INSERT policy decision deferred to Story 1.3+ based on auth flow

### Improvements Checklist

- [x] Add UPDATE RLS policy to users table (completed in migration 004)
- [x] Add name column for optional natural language onboarding (completed in migration 005)
- [ ] Decide INSERT policy approach in Story 1.3 based on chosen auth flow
- [ ] Consider adding `updated_at` timestamp to captures table for audit trail (future enhancement)

### Files Modified During Review

None. No refactoring needed.

### Gate Status

**Gate: PASS** → docs/qa/gates/1.2-database-schema-and-captures-table.yml

**Quality Score: 95/100**

**Issues:** None blocking

**Reason**: Schema implementation is excellent. All foundational RLS policies in place. UPDATE policy added. INSERT policy decision appropriately deferred to implementation stories based on auth flow selection.

### Recommended Status

**✓ Ready for Done**

All acceptance criteria met. Implementation is production-quality. INSERT policy decision deferred to Story 1.3+ implementation.

### Manual Verification Checklist

**Key Clarification - How Media Storage Works:**

The `media_url` column stores **URL references** to media files, NOT binary data. This is the correct pattern:

- **Photos/Videos**: Stored in Supabase Storage (object storage), `media_url` contains the URL path
- **Text Messages**: Stored directly in `text_content` column
- **Why URL references?**: Storing binary data (BYTEA) in PostgreSQL is slow, expensive, and prevents CDN caching. Object storage is optimized for serving media files.

**Example Data:**
```sql
-- Photo capture (media_url has URL, text_content is NULL)
content_type='photo', media_url='storage/captures/user-id/IMG_001.jpg', text_content=NULL

-- Text capture (text_content has message, media_url is NULL)
content_type='text', text_content='Hello world', media_url=NULL
```

**Note**: Supabase Storage bucket setup will be handled in a future story. This story establishes the schema foundation.

See full manual verification steps in separate checklist provided to user.
